/* *
 * Scanner for the class project in COP5556 Programming Language Principles
 * at the University of Florida, Fall 2017.
 *
 * This software is solely for the educational benefit of students
 * enrolled in the course during the Fall 2017 semester.
 *
 * This software, and any software derived from it,  may not be shared with others or posted to public web sites,
 * either during the course or afterwards.
 *
 *  @Beverly A. Sanders, 2017
  */

package cop5556fa17;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;

public class Scanner {

	@SuppressWarnings("serial")
	public static class LexicalException extends Exception {

		int pos;

		public LexicalException(String message, int pos) {
			super(message);
			this.pos = pos;
		}

		public int getPos() { return pos; }

	}

	public static enum Kind {
		IDENTIFIER, INTEGER_LITERAL, BOOLEAN_LITERAL, STRING_LITERAL,
		KW_x/* x */, KW_X/* X */, KW_y/* y */, KW_Y/* Y */, KW_r/* r */, KW_R/* R */, KW_a/* a */,
		KW_A/* A */, KW_Z/* Z */, KW_DEF_X/* DEF_X */, KW_DEF_Y/* DEF_Y */, KW_SCREEN/* SCREEN */,
		KW_cart_x/* cart_x */, KW_cart_y/* cart_y */, KW_polar_a/* polar_a */, KW_polar_r/* polar_r */,
		KW_abs/* abs */, KW_sin/* sin */, KW_cos/* cos */, KW_atan/* atan */, KW_log/* log */,
		KW_image/* image */,  KW_int/* int */,
		KW_boolean/* boolean */, KW_url/* url */, KW_file/* file */, OP_ASSIGN/* = */, OP_GT/* > */, OP_LT/* < */,
		OP_EXCL/* ! */, OP_Q/* ? */, OP_COLON/* : */, OP_EQ/* == */, OP_NEQ/* != */, OP_GE/* >= */, OP_LE/* <= */,
		OP_AND/* & */, OP_OR/* | */, OP_PLUS/* + */, OP_MINUS/* - */, OP_TIMES/* * */, OP_DIV/* / */, OP_MOD/* % */,
		OP_POWER/* ** */, OP_AT/* @ */, OP_RARROW/* -> */, OP_LARROW/* <- */, LPAREN/* ( */, RPAREN/* ) */,
		LSQUARE/* [ */, RSQUARE/* ] */, SEMI/* ; */, COMMA/* , */, EOF;
	}

	/** Class to represent Tokens.
	 *
	 * This is defined as a (non-static) inner class
	 * which means that each Token instance is associated with a specific
	 * Scanner instance.  We use this when some token methods access the
	 * chars array in the associated Scanner.
	 *
	 *
	 * @author Beverly Sanders
	 *
	 */
	public final ArrayList<Integer> arrayLine = new ArrayList<Integer>();
	public static enum State {
		START, IN_DIGIT, IN_IDENT, STRING_LITERAL, BOOLEAN_LITERAL, AFTER_EQ, AFTER_SLASH, AFTER_MINUS, AFTER_STAR, AFTER_EXCLAMATION, AFTER_GREATER, AFTER_LESS, AFTER_PIPE;
	}

	public class Token {
		public final Kind kind;
		public final int pos;
		public final int length;
		public final int line;
		public final int pos_in_line;

		public Token(Kind kind, int pos, int length, int line, int pos_in_line) {
			super();
			this.kind = kind;
			this.pos = pos;
			this.length = length;
			this.line = line;
			this.pos_in_line = pos_in_line;
		}

		public String getText() {
			if (kind == Kind.STRING_LITERAL) {
				return chars2String(chars, pos, length);
			}
			else return String.copyValueOf(chars, pos, length);
		}

		/**
		 * To get the text of a StringLiteral, we need to remove the
		 * enclosing " characters and convert escaped characters to
		 * the represented character.  For example the two characters \ t
		 * in the char array should be converted to a single tab character in
		 * the returned String
		 *
		 * @param chars
		 * @param pos
		 * @param length
		 * @return
		 */
		private String chars2String(char[] chars, int pos, int length) {
			StringBuilder sb = new StringBuilder();
			for (int i = pos + 1; i < pos + length - 1; ++i) {// omit initial and final "
				char ch = chars[i];
				if (ch == '\\') { // handle escape
					i++;
					ch = chars[i];
					switch (ch) {
					case 'b':
						sb.append('\b');
						break;
					case 't':
						sb.append('\t');
						break;
					case 'f':
						sb.append('\f');
						break;
					case 'r':
						sb.append('\r'); //for completeness, line termination chars not allowed in String literals
						break;
					case 'n':
						sb.append('\n'); //for completeness, line termination chars not allowed in String literals
						break;
					case '\"':
						sb.append('\"');
						break;
					case '\'':
						sb.append('\'');
						break;
					case '\\':
						sb.append('\\');
						break;
					default:
						assert false;
						break;
					}
				} else {
					sb.append(ch);
				}
			}
			return sb.toString();
		}


		/**
		 * precondition:  This Token is an INTEGER_LITERAL
		 *
		 * @returns the integer value represented by the token
		 */
		public int intVal() {
			assert kind == Kind.INTEGER_LITERAL;
			return Integer.valueOf(String.copyValueOf(chars, pos, length));
		}

		public String toString() {
			return "[" + kind + "," + String.copyValueOf(chars, pos, length)  + "," + pos + "," + length + "," + line + ","
					+ pos_in_line + "]";
		}

		/**
		 * Since we overrode equals, we need to override hashCode.
		 * https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals-java.lang.Object-
		 *
		 * Both the equals and hashCode method were generated by eclipse
		 *
		 */
		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + getOuterType().hashCode();
			result = prime * result + ((kind == null) ? 0 : kind.hashCode());
			result = prime * result + length;
			result = prime * result + line;
			result = prime * result + pos;
			result = prime * result + pos_in_line;
			return result;
		}

		/**
		 * Override equals method to return true if other object
		 * is the same class and all fields are equal.
		 *
		 * Overriding this creates an obligation to override hashCode.
		 *
		 * Both hashCode and equals were generated by eclipse.
		 *
		 */
		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			Token other = (Token) obj;
			if (!getOuterType().equals(other.getOuterType()))
				return false;
			if (kind != other.kind)
				return false;
			if (length != other.length)
				return false;
			if (line != other.line)
				return false;
			if (pos != other.pos)
				return false;
			if (pos_in_line != other.pos_in_line)
				return false;
			return true;
		}

		/**
		 * used in equals to get the Scanner object this Token is
		 * associated with.
		 * @return
		 */
		private Scanner getOuterType() {
			return Scanner.this;
		}

	}

	/**
	 * Extra character added to the end of the input characters to simplify the
	 * Scanner.
	 */
	static final char EOFchar = 0;

	/**
	 * The list of tokens created by the scan method.
	 */
	final ArrayList<Token> tokens;

	/**
	 * An array of characters representing the input.  These are the characters
	 * from the input string plus and additional EOFchar at the end.
	 */
	final char[] chars;




	/**
	 * position of the next token to be returned by a call to nextToken
	 */
	private int nextTokenPos = 0;

	Scanner(String inputString) {
		int numChars = inputString.length();
		this.chars = Arrays.copyOf(inputString.toCharArray(), numChars + 1); // input string terminated with null char
		chars[numChars] = EOFchar;
		tokens = new ArrayList<Token>();
	}

	int posinline=1;

	public int skipWhiteSpace(int pos) {
		// TODO Auto-generated method stub
		while (pos < chars.length) {
				if (chars[pos] == '\t' || chars[pos] ==' ') {
					pos++;
					posinline++;
				}
				else
					break;
			}
		return pos;
	}
	/**
	 * Method to scan the input and create a list of Tokens.
	 *
	 * If an error is encountered during scanning, throw a LexicalException.
	 *
	 * @return
	 * @throws LexicalException
	 */
	public Scanner scan() throws LexicalException {
		/* TODO  Replace this with a correct and complete implementation!!! */
		int pos = 0;
		//arrayLine.add(0);
		int length =chars.length-1;
		//System.out.println("length = "+length);
		State state = State.START;
		int startPos = 0;
		int ch;
		int line=1;

		int startposinline=0;
		while(pos<=length) {
			ch=pos<length?chars[pos]:-1;
			switch(state) {
				case START:{
				pos = skipWhiteSpace(pos);
				ch = pos < length ? chars[pos] : -1;
				startPos = pos;
				startposinline=posinline;
				switch (ch) {
				case -1: {
					tokens.add(new Token(Kind.EOF, pos, 0,line,startposinline));
					pos++;
				}
				break;
				case '+': {
					tokens.add(new Token(Kind.OP_PLUS, startPos, 1,line,startposinline));
					pos++;
					posinline++;
				}
					break;
				case '0': {
					tokens.add(new Token(Kind.INTEGER_LITERAL, startPos, 1,line,startposinline));
					pos++;
					posinline++;
				}
					break;
				case '*': {
					if (pos + 1 < length) {
						state = State.AFTER_STAR;
						pos++;
						posinline++;
					} else {
						tokens.add(new Token(Kind.OP_TIMES, startPos, 1,line,startposinline));
						state = State.START;
						pos++;
						posinline++;
					}
				}
					break;

				case '?': {
					tokens.add(new Token(Kind.OP_Q, startPos, 1,line,startposinline));
					pos++;
					posinline++;
				}
					break;
				case ':': {
					tokens.add(new Token(Kind.OP_COLON, startPos, 1,line,startposinline));
					pos++;
					posinline++;
				}
					break;
				case '%': {
					tokens.add(new Token(Kind.OP_MOD, startPos, 1,line,startposinline));
					pos++;
					posinline++;
				}
					break;
				case '&': {
					tokens.add(new Token(Kind.OP_AND, startPos, 1,line,startposinline));
					pos++;
					posinline++;
				}
					break;
				case '@': {
					tokens.add(new Token(Kind.OP_AT, startPos, 1,line,startposinline));
					pos++;
					posinline++;
				}
					break;
				case '(': {
					tokens.add(new Token(Kind.LPAREN, startPos, 1,line,startposinline));
					pos++;
					posinline++;
				}
					break;
				case ')': {
					tokens.add(new Token(Kind.RPAREN, startPos, 1,line,startposinline));
					pos++;
					posinline++;
				}
					break;
				case '[': {
					tokens.add(new Token(Kind.LSQUARE, startPos, 1,line,startposinline));
					pos++;
					posinline++;
				}
					break;
				case ']': {
					tokens.add(new Token(Kind.RSQUARE, startPos, 1,line,startposinline));
					pos++;
					posinline++;
				}
					break;
				case ';': {
					tokens.add(new Token(Kind.SEMI, startPos, 1,line,startposinline));
					pos++;
					posinline++;
				}
					break;
				case ',': {
					tokens.add(new Token(Kind.COMMA, startPos, 1,line,startposinline));
					pos++;
					posinline++;
				}
					break;

				case '\n': {
					line++;
					pos++;
					posinline=1;
				}
					break;

				case '\r': {
					line++;
					pos++;
					posinline=1;
					if(chars[pos]=='\n') {
						pos++;
					}
				}
					break;
				
				case '\f': {					
					pos++;
					posinline++;
				}
					break;
				

				case '|': {
					
					
						tokens.add(new Token(Kind.OP_OR, startPos, 1,line,startposinline));
						state = State.START;
						pos++;
						posinline++;
				}
					break;
				
				case '=': {
					if (pos + 1 < length) {
						state = State.AFTER_EQ;
						pos++;
						posinline++;
					} else {
						tokens.add(new Token(Kind.OP_ASSIGN, startPos, 1,line,startposinline));
						state = State.START;
						pos++;
						posinline++;
					}
				}
					break;

				case '>': {
					if (pos + 1 < length) {
						state = State.AFTER_GREATER;
						pos++;
						posinline++;
					} else {
						tokens.add(new Token(Kind.OP_GT, startPos, 1,line,startposinline));
						state = State.START;
						pos++;
						posinline++;
					}

					// state = State.AFTER_GREATER;pos++;
				}
					break;
				case '<': {
					if (pos + 1 < length) {
						state = State.AFTER_LESS;
						pos++;
						posinline++;
					} else {
						tokens.add(new Token(Kind.OP_LT, startPos, 1,line,startposinline));
						state = State.START;
						pos++;
						posinline++;
					}

					// pos++;
				}
					break;
				case '!': {
					if (pos + 1 < length) {
						state = State.AFTER_EXCLAMATION;
						pos++;
						posinline++;
					} else {
						tokens.add(new Token(Kind.OP_EXCL, startPos, 1,line,startposinline));
						state = State.START;
						pos++;
						posinline++;
					}
					// pos++;
				}
					break;
				case '-': {
					if (pos + 1 < length) {
						state = State.AFTER_MINUS;
						pos++;
						posinline++;
					} else {
						tokens.add(new Token(Kind.OP_MINUS, startPos, 1,line,startposinline));
						state = State.START;
						pos++;
						posinline++;
					}

					// pos++;
				}
					break;
				case '/': {
					if (pos + 1 < length && chars[pos+1]=='/') {
						//System.out.println("position after slash:"+(pos+1));
						state = State.AFTER_SLASH;
						pos++;
						posinline++;
					} else {
						//System.out.println((pos+1)+","+length);
						tokens.add(new Token(Kind.OP_DIV, startPos, 1,line,startposinline));
						state = State.START;
						pos++;
						posinline++;
					}

					// pos++;
				}
					break;
				case '"':{
						state=State.STRING_LITERAL;
						pos++;
						posinline++;
						}
				break;
				default: {
					if (Character.isDigit(ch)) {
						state = State.IN_DIGIT;
						pos++;
						posinline++;
					} else if (Character.isJavaIdentifierStart(ch)) {
						state = State.IN_IDENT;
						pos++;
						posinline++;
					} else {
						throw new LexicalException("illegal char" + (char) ch + " at pos " + pos,pos);
					}
				}break;

				}

				break;
				}
				case IN_DIGIT: {
					// System.out.println("In In_Digit state");
					int digitLength = 1;
					StringBuilder digitStr = new StringBuilder();
					digitStr.append(chars[pos - 1]);
					while (pos < length && Character.isDigit(chars[pos])) {
						digitStr.append(chars[pos]);
						pos++;
						posinline++;
						digitLength++;
					}
					Long val = Long.valueOf(Integer.MAX_VALUE);
					BigInteger bigInt = new BigInteger(digitStr.toString());
					if (bigInt.compareTo(BigInteger.valueOf(val)) > 0) {
						throw new LexicalException("Integer value is out of bound",pos);
					}
					tokens.add(new Token(Kind.INTEGER_LITERAL, startPos, digitLength,line,startposinline));

					state = State.START;
				}
					break;
				case IN_IDENT: {
					// System.out.println("In IDent state");
					StringBuilder str = new StringBuilder();
					int strLength;
					str.append(chars[pos - 1]);
					while (pos < length && Character.isJavaIdentifierPart(chars[pos])) {

						str.append(chars[pos]);
						pos++;
						posinline++;
						// chars.charAt(pos);
					}
					strLength = str.length();
					switch (str.toString()) {
					case "integer": {
						tokens.add(new Token(Kind.KW_int, startPos, strLength,line,startposinline));
					}
						break;
					case "boolean": {
						tokens.add(new Token(Kind.KW_boolean, startPos, strLength,line,startposinline));
					}
						break;
					case "image": {
						tokens.add(new Token(Kind.KW_image, startPos, strLength,line,startposinline));
					}
						break;
					case "url": {
						tokens.add(new Token(Kind.KW_url, startPos, strLength,line,startposinline));
					}
						break;
					case "file": {
						tokens.add(new Token(Kind.KW_file, startPos, strLength,line,startposinline));
					}
						break;
					case "x": {
						tokens.add(new Token(Kind.KW_x, startPos, strLength,line,startposinline));
					}
						break;
					case "X": {
						tokens.add(new Token(Kind.KW_X, startPos, strLength,line,startposinline));
					}
						break;
					case "y": {
						tokens.add(new Token(Kind.KW_y, startPos, strLength,line,startposinline));
					}
						break;
					case "Y": {
						tokens.add(new Token(Kind.KW_Y, startPos, strLength,line,startposinline));
					}
						break;
					case "r": {
						tokens.add(new Token(Kind.KW_r, startPos, strLength,line,startposinline));
					}
						break;
					case "R": {
						tokens.add(new Token(Kind.KW_R, startPos, strLength,line,startposinline));
					}
						break;
					case "a": {
						tokens.add(new Token(Kind.KW_a, startPos, strLength,line,startposinline));
					}
						break;
					case "A": {
						tokens.add(new Token(Kind.KW_A, startPos, strLength,line,startposinline));
					}
						break;
					case "Z": {
						tokens.add(new Token(Kind.KW_Z, startPos, strLength,line,startposinline));
					}
						break;
					case "DEF_X": {
						tokens.add(new Token(Kind.KW_DEF_X, startPos, strLength,line,startposinline));
					}
						break;
					case "DEF_Y": {
						tokens.add(new Token(Kind.KW_DEF_Y, startPos, strLength,line,startposinline));
					}
						break;
					case "SCREEN": {
						tokens.add(new Token(Kind.KW_SCREEN, startPos, strLength,line,startposinline));
					}
						break;
					case "cart_x": {
						tokens.add(new Token(Kind.KW_cart_x, startPos, strLength,line,startposinline));
					}
						break;
					case "cart_y": {
						tokens.add(new Token(Kind.KW_cart_y, startPos, strLength,line,startposinline));
					}
						break;
					case "polar_a": {
						tokens.add(new Token(Kind.KW_polar_a, startPos, strLength,line,startposinline));
					}
						break;
					case "polar_r": {
						tokens.add(new Token(Kind.KW_polar_r, startPos, strLength,line,startposinline));
					}
						break;
					case "abs": {
						tokens.add(new Token(Kind.KW_abs, startPos, strLength,line,startposinline));
					}
						break;
					case "sin": {
						tokens.add(new Token(Kind.KW_sin, startPos, strLength,line,startposinline));
					}
						break;
					case "cos": {
						tokens.add(new Token(Kind.KW_cos, startPos, strLength,line,startposinline));
					}
						break;
					case "atan": {
						tokens.add(new Token(Kind.KW_atan, startPos, strLength,line,startposinline));
					}
						break;
					case "log": {
						tokens.add(new Token(Kind.KW_log, startPos, strLength,line,startposinline));
					}
						break;
					case "int": {
						tokens.add(new Token(Kind.KW_int, startPos, strLength,line,startposinline));
					}
						break;
					case "true": {
						tokens.add(new Token(Kind.BOOLEAN_LITERAL, startPos, strLength,line,startposinline));
					}
						break;
					case "false": {
						//System.out.println("here in false");
						tokens.add(new Token(Kind.BOOLEAN_LITERAL, startPos, strLength,line,startposinline));
					}
						break;

					default: {
						tokens.add(new Token(Kind.IDENTIFIER, startPos, strLength,line,startposinline));
					}
					}
					// System.out.println("Outside Ident");
					state = State.START;

				}
					break;
				case AFTER_EQ: {
					// System.out.println("In equal state");
					ch = chars[pos];
					//
					if (ch == '=') {
						tokens.add(new Token(Kind.OP_EQ, startPos, 2,line,startposinline));
						pos++;
						posinline++;
						state = State.START;
					} else {
						//
						tokens.add(new Token(Kind.OP_ASSIGN, startPos, 1,line,startposinline));
						state = State.START;
					//	throw new LexicalException("illegal char " + (char) ch + " at pos " + pos,pos);

					}
				}
					break;
				case AFTER_STAR: {
					// System.out.println("In equal state");
					ch = chars[pos];
					//
					if (ch == '*') {
						tokens.add(new Token(Kind.OP_POWER, startPos, 2,line,startposinline));
						pos++;
						posinline++;
						state = State.START;
					} else {
						//
						tokens.add(new Token(Kind.OP_TIMES, startPos, 1,line,startposinline));
						state = State.START;
						//throw new LexicalException("illegal char " + (char) ch + " at pos " + pos,pos);

					}
				}
				break;


				case AFTER_GREATER: {
					// System.out.println("In Greater state");
					ch = chars[pos];
					//
					if (ch == '=') {
						tokens.add(new Token(Kind.OP_GE, startPos, 2,line,startposinline));
						pos++;
						posinline++;
						state = State.START;
					} else {
						tokens.add(new Token(Kind.OP_GT, startPos, 1,line,startposinline));
						state = State.START;
					}
				}
					break;
				case STRING_LITERAL:{
					//System.out.println("In literal");
					ch=chars[pos];
					//System.out.println((char)ch+","+pos);
					if(ch!='"') {
						if(ch=='\\') {
							if(chars[pos+1]=='\\'||chars[pos+1]=='"') {
								//System.out.println("inside 1: "+(char)ch);
								pos=pos+2;
								posinline=posinline+2;

							}
							else if(!(chars[pos+1]=='n'||chars[pos+1]=='b'||chars[pos+1]=='t'||chars[pos+1]=='f'||chars[pos+1]=='r')) {
								throw new LexicalException("illegal char at " + (char) ch + " at pos " + pos,pos+1);
							}
							else {
								pos++;
								posinline++;
							}
						}
						else if(ch=='\n'||ch=='\r') {
							throw new LexicalException("illegal char \n \r" + (char) ch + " at pos " + pos,pos);
						}
						else if(ch==EOFchar) {
							throw new LexicalException("illegal char " + (char) ch + " at pos " + pos,pos);
						}
						else {
							pos++;
							posinline++;
						}
					}
					else {

						tokens.add(new Token(Kind.STRING_LITERAL, startPos, ++pos-startPos,line,startposinline));
						//System.out.println(pos+" ");
						posinline++;
						state=state.START;
					}
				}
				break;
				case AFTER_LESS: {
					// System.out.println("In Less state");
					ch = chars[pos];
					//
					if (ch == '=') {
						tokens.add(new Token(Kind.OP_LE, startPos, 2,line,startposinline));
						pos++;
						posinline++;
						state = State.START;
					} else if (ch == '-') {
						tokens.add(new Token(Kind.OP_LARROW, startPos, 2,line,startposinline));
						pos++;
						posinline++;
						state = State.START;
					} else {
						tokens.add(new Token(Kind.OP_LT, startPos, 1,line,startposinline));
						state = State.START;
					}

				}
					break;
				case AFTER_EXCLAMATION: {
					// System.out.println("In Exclamation state");
					ch = chars[pos];
					//
					if (ch == '=') {
						tokens.add(new Token(Kind.OP_NEQ, startPos, 2,line,startposinline));
						pos++;
						posinline++;
						state = State.START;
					} else {
						tokens.add(new Token(Kind.OP_EXCL, startPos, 1,line,startposinline));
						state = State.START;
					}
				}
					break;

				case AFTER_MINUS: {
					ch = chars[pos];
					if (ch == '>') {
						tokens.add(new Token(Kind.OP_RARROW, startPos, 2,line,startposinline));
						pos++;
						posinline++;
						state = State.START;
					} else {
						tokens.add(new Token(Kind.OP_MINUS, startPos, 1,line,startposinline));
						state = State.START;
					}
				}
					break;

				case AFTER_SLASH: {

					ch = chars[pos];
					//System.out.println("Char AFTER SLASHHHHHHHHH is: "+(char)ch);
					while(pos<length && chars[pos]!='\n' &&  chars[pos]!='\r') {
							pos++;
							posinline++;
						//	System.out.println("AFTER SLASH IN WHILEEEEE.............");
					}
					
					state=state.START;
				}
					break;
				default:
					assert false;

			}
			}



		return this;
	}


	/**
	 * Returns true if the internal interator has more Tokens
	 *
	 * @return
	 */
	public boolean hasTokens() {
		return nextTokenPos < tokens.size();
	}

	/**
	 * Returns the next Token and updates the internal iterator so that
	 * the next call to nextToken will return the next token in the list.
	 *
	 * It is the callers responsibility to ensure that there is another Token.
	 *
	 * Precondition:  hasTokens()
	 * @return
	 */
	public Token nextToken() {
		return tokens.get(nextTokenPos++);
	}

	/**
	 * Returns the next Token, but does not update the internal iterator.
	 * This means that the next call to nextToken or peek will return the
	 * same Token as returned by this methods.
	 *
	 * It is the callers responsibility to ensure that there is another Token.
	 *
	 * Precondition:  hasTokens()
	 *
	 * @return next Token.
	 */
	public Token peek() {
		return tokens.get(nextTokenPos);
	}


	/**
	 * Resets the internal iterator so that the next call to peek or nextToken
	 * will return the first Token.
	 */
	public void reset() {
		nextTokenPos = 0;
	}

	/**
	 * Returns a String representation of the list of Tokens
	 */
	public String toString() {
		StringBuffer sb = new StringBuffer();
		sb.append("Tokens:\n");
		for (int i = 0; i < tokens.size(); i++) {
			sb.append(tokens.get(i)).append('\n');
		}
		return sb.toString();
	}

}
